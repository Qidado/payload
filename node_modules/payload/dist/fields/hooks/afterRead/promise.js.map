{"version":3,"sources":["../../../../src/fields/hooks/afterRead/promise.ts"],"sourcesContent":["import type { RichTextAdapter } from '../../../admin/RichText.js'\nimport type { SanitizedCollectionConfig } from '../../../collections/config/types.js'\nimport type { SanitizedGlobalConfig } from '../../../globals/config/types.js'\nimport type {\n  JsonObject,\n  PayloadRequest,\n  PopulateType,\n  SelectMode,\n  SelectType,\n} from '../../../types/index.js'\nimport type { Block, Field, TabAsField } from '../../config/types.js'\n\nimport { MissingEditorProp } from '../../../errors/index.js'\nimport { type RequestContext } from '../../../index.js'\nimport { getBlockSelect } from '../../../utilities/getBlockSelect.js'\nimport { stripUnselectedFields } from '../../../utilities/stripUnselectedFields.js'\nimport { fieldAffectsData, fieldShouldBeLocalized, tabHasName } from '../../config/types.js'\nimport { getDefaultValue } from '../../getDefaultValue.js'\nimport { getFieldPathsModified as getFieldPaths } from '../../getFieldPaths.js'\nimport { relationshipPopulationPromise } from './relationshipPopulationPromise.js'\nimport { traverseFields } from './traverseFields.js'\nimport { virtualFieldPopulationPromise } from './virtualFieldPopulationPromise.js'\n\ntype Args = {\n  /**\n   * Data of the nearest parent block. If no parent block exists, this will be the `undefined`\n   */\n  blockData?: JsonObject\n  collection: null | SanitizedCollectionConfig\n  context: RequestContext\n  currentDepth: number\n  depth: number\n  doc: JsonObject\n  draft: boolean\n  fallbackLocale: null | string\n  field: Field | TabAsField\n  fieldIndex: number\n  /**\n   * fieldPromises are used for things like field hooks. They should be awaited before awaiting populationPromises\n   */\n  fieldPromises: Promise<void>[]\n  findMany: boolean\n  flattenLocales: boolean\n  global: null | SanitizedGlobalConfig\n  locale: null | string\n  overrideAccess: boolean\n  parentIndexPath: string\n  /**\n   * @todo make required in v4.0\n   */\n  parentIsLocalized?: boolean\n  parentPath: string\n  parentSchemaPath: string\n  populate?: PopulateType\n  populationPromises: Promise<void>[]\n  req: PayloadRequest\n  select?: SelectType\n  selectMode?: SelectMode\n  showHiddenFields: boolean\n  siblingDoc: JsonObject\n  siblingFields?: (Field | TabAsField)[]\n  triggerAccessControl?: boolean\n  triggerHooks?: boolean\n}\n\n// This function is responsible for the following actions, in order:\n// - Remove hidden fields from response\n// - Flatten locales into requested locale\n// - Sanitize outgoing data (point field, etc.)\n// - Execute field hooks\n// - Execute read access control\n// - Populate relationships\n\nexport const promise = async ({\n  blockData,\n  collection,\n  context,\n  currentDepth,\n  depth,\n  doc,\n  draft,\n  fallbackLocale,\n  field,\n  fieldIndex,\n  fieldPromises,\n  findMany,\n  flattenLocales,\n  global,\n  locale,\n  overrideAccess,\n  parentIndexPath,\n  parentIsLocalized,\n  parentPath,\n  parentSchemaPath,\n  populate,\n  populationPromises,\n  req,\n  select,\n  selectMode,\n  showHiddenFields,\n  siblingDoc,\n  siblingFields,\n  triggerAccessControl = true,\n  triggerHooks = true,\n}: Args): Promise<void> => {\n  const { indexPath, path, schemaPath } = getFieldPaths({\n    field,\n    index: fieldIndex,\n    parentIndexPath,\n    parentPath,\n    parentSchemaPath,\n  })\n\n  const fieldAffectsDataResult = fieldAffectsData(field)\n  const pathSegments = path ? path.split('.') : []\n  const schemaPathSegments = schemaPath ? schemaPath.split('.') : []\n  const indexPathSegments = indexPath ? indexPath.split('-').filter(Boolean)?.map(Number) : []\n  let removedFieldValue = false\n\n  if (\n    fieldAffectsDataResult &&\n    field.hidden &&\n    typeof siblingDoc[field.name!] !== 'undefined' &&\n    !showHiddenFields\n  ) {\n    removedFieldValue = true\n    delete siblingDoc[field.name!]\n  }\n\n  if (path !== 'id') {\n    const shouldContinue = stripUnselectedFields({\n      field,\n      select: select!,\n      selectMode: selectMode!,\n      siblingDoc,\n    })\n\n    if (!shouldContinue) {\n      return\n    }\n  }\n\n  const shouldHoistLocalizedValue: boolean = Boolean(\n    flattenLocales &&\n      fieldAffectsDataResult &&\n      typeof siblingDoc[field.name!] === 'object' &&\n      siblingDoc[field.name!] !== null &&\n      fieldShouldBeLocalized({ field, parentIsLocalized: parentIsLocalized! }) &&\n      locale !== 'all' &&\n      req.payload.config.localization,\n  )\n\n  if (fieldAffectsDataResult && shouldHoistLocalizedValue) {\n    // replace actual value with localized value before sanitizing\n    // { [locale]: fields } -> fields\n    const value = siblingDoc[field.name!][locale!]\n\n    let hoistedValue = value\n\n    if (fallbackLocale && fallbackLocale !== locale) {\n      const fallbackValue = siblingDoc[field.name!][fallbackLocale]\n      const isNullOrUndefined = typeof value === 'undefined' || value === null\n\n      if (fallbackValue) {\n        switch (field.type) {\n          case 'text':\n          case 'textarea': {\n            if (value === '' || isNullOrUndefined) {\n              hoistedValue = fallbackValue\n            }\n            break\n          }\n\n          default: {\n            if (isNullOrUndefined) {\n              hoistedValue = fallbackValue\n            }\n            break\n          }\n        }\n      }\n    }\n\n    siblingDoc[field.name!] = hoistedValue\n  }\n\n  // Sanitize outgoing field value\n  switch (field.type) {\n    case 'group': {\n      // Fill groups with empty objects so fields with hooks within groups can populate\n      // themselves virtually as necessary\n      if (fieldAffectsDataResult && typeof siblingDoc[field.name] === 'undefined') {\n        siblingDoc[field.name] = {}\n      }\n\n      break\n    }\n    case 'point': {\n      const pointDoc = siblingDoc[field.name] as Record<string, unknown>\n      if (Array.isArray(pointDoc?.coordinates) && pointDoc.coordinates.length === 2) {\n        siblingDoc[field.name] = pointDoc.coordinates\n      } else {\n        siblingDoc[field.name] = undefined\n      }\n\n      break\n    }\n\n    case 'richText': {\n      if (!field?.editor) {\n        throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n      }\n      if (typeof field?.editor === 'function') {\n        throw new Error('Attempted to access unsanitized rich text editor.')\n      }\n\n      // Rich Text fields should use afterRead hooks to do population. The previous editor.populationPromises have been renamed to editor.graphQLPopulationPromises\n      break\n    }\n\n    case 'tabs': {\n      field.tabs.forEach((tab) => {\n        if (\n          tabHasName(tab) &&\n          (typeof siblingDoc[tab.name] === 'undefined' || siblingDoc[tab.name] === null)\n        ) {\n          siblingDoc[tab.name] = {}\n        }\n      })\n\n      break\n    }\n\n    default: {\n      break\n    }\n  }\n\n  if (fieldAffectsDataResult) {\n    // Execute hooks\n    if (triggerHooks && field.hooks?.afterRead) {\n      for (const hook of field.hooks.afterRead) {\n        const shouldRunHookOnAllLocales =\n          fieldShouldBeLocalized({ field, parentIsLocalized: parentIsLocalized! }) &&\n          (locale === 'all' || !flattenLocales) &&\n          typeof siblingDoc[field.name!] === 'object'\n\n        if (shouldRunHookOnAllLocales) {\n          const localesAndValues = Object.entries(siblingDoc[field.name!])\n          await Promise.all(\n            localesAndValues.map(async ([localeKey, value]) => {\n              const hookedValue = await hook({\n                blockData,\n                collection,\n                context,\n                currentDepth,\n                data: doc,\n                depth,\n                draft,\n                field,\n                findMany,\n                global,\n                indexPath: indexPathSegments,\n                operation: 'read',\n                originalDoc: doc,\n                overrideAccess,\n                path: pathSegments,\n                req,\n                schemaPath: schemaPathSegments,\n                showHiddenFields,\n                siblingData: siblingDoc,\n                siblingFields: siblingFields!,\n                value,\n              })\n\n              if (hookedValue !== undefined) {\n                siblingDoc[field.name!][localeKey] = hookedValue\n              }\n            }),\n          )\n        } else {\n          const hookedValue = await hook({\n            blockData,\n            collection,\n            context,\n            currentDepth,\n            data: doc,\n            depth,\n            draft,\n            field,\n            findMany,\n            global,\n            indexPath: indexPathSegments,\n            operation: 'read',\n            originalDoc: doc,\n            overrideAccess,\n            path: pathSegments,\n            req,\n            schemaPath: schemaPathSegments,\n            showHiddenFields,\n            siblingData: siblingDoc,\n            siblingFields: siblingFields!,\n            value: siblingDoc[field.name!],\n          })\n\n          if (hookedValue !== undefined) {\n            siblingDoc[field.name!] = hookedValue\n          }\n        }\n      }\n    }\n\n    if (\n      'virtual' in field &&\n      typeof field.virtual === 'string' &&\n      (!field.hidden || showHiddenFields)\n    ) {\n      populationPromises.push(\n        virtualFieldPopulationPromise({\n          name: field.name,\n          draft,\n          fallbackLocale: fallbackLocale!,\n          fields: (collection || global)!.flattenedFields,\n          locale: locale!,\n          overrideAccess,\n          ref: doc,\n          req,\n          segments: field.virtual.split('.'),\n          showHiddenFields,\n          siblingDoc,\n        }),\n      )\n    }\n\n    // Execute access control\n    let allowDefaultValue = true\n    if (triggerAccessControl && field.access && field.access.read) {\n      const canReadField = overrideAccess\n        ? true\n        : await field.access.read({\n            id: doc.id as number | string,\n            blockData,\n            data: doc,\n            doc,\n            req,\n            siblingData: siblingDoc,\n          })\n\n      if (!canReadField) {\n        allowDefaultValue = false\n        delete siblingDoc[field.name!]\n      }\n    }\n\n    // Set defaultValue on the field for globals being returned without being first created\n    // or collection documents created prior to having a default\n    if (\n      !removedFieldValue &&\n      allowDefaultValue &&\n      typeof siblingDoc[field.name!] === 'undefined' &&\n      typeof field.defaultValue !== 'undefined'\n    ) {\n      siblingDoc[field.name!] = await getDefaultValue({\n        defaultValue: field.defaultValue,\n        locale: locale!,\n        req,\n        user: req.user,\n        value: siblingDoc[field.name!],\n      })\n    }\n\n    if (field.type === 'relationship' || field.type === 'upload' || field.type === 'join') {\n      populationPromises.push(\n        relationshipPopulationPromise({\n          currentDepth,\n          depth,\n          draft,\n          fallbackLocale,\n          field,\n          locale,\n          overrideAccess,\n          parentIsLocalized: parentIsLocalized!,\n          populate,\n          req,\n          showHiddenFields,\n          siblingDoc,\n        }),\n      )\n    }\n  }\n\n  switch (field.type) {\n    case 'array': {\n      const rows = siblingDoc[field.name] as JsonObject\n\n      let arraySelect = select?.[field.name]\n\n      if (selectMode === 'include' && typeof arraySelect === 'object') {\n        arraySelect = {\n          ...arraySelect,\n          id: true,\n        }\n      }\n\n      if (Array.isArray(rows) && rows.length > 0) {\n        rows.forEach((row, rowIndex) => {\n          traverseFields({\n            blockData,\n            collection,\n            context,\n            currentDepth,\n            depth,\n            doc,\n            draft,\n            fallbackLocale,\n            fieldPromises,\n            fields: field.fields,\n            findMany,\n            flattenLocales,\n            global,\n            locale,\n            overrideAccess,\n            parentIndexPath: '',\n            parentIsLocalized: parentIsLocalized || field.localized,\n            parentPath: path + '.' + rowIndex,\n            parentSchemaPath: schemaPath,\n            populate,\n            populationPromises,\n            req,\n            select: typeof arraySelect === 'object' ? arraySelect : undefined,\n            selectMode,\n            showHiddenFields,\n            siblingDoc: row || {},\n            triggerAccessControl,\n            triggerHooks,\n          })\n        })\n      } else if (!shouldHoistLocalizedValue && typeof rows === 'object' && rows !== null) {\n        Object.values(rows).forEach((localeRows) => {\n          if (Array.isArray(localeRows)) {\n            localeRows.forEach((row, rowIndex) => {\n              traverseFields({\n                blockData,\n                collection,\n                context,\n                currentDepth,\n                depth,\n                doc,\n                draft,\n                fallbackLocale,\n                fieldPromises,\n                fields: field.fields,\n                findMany,\n                flattenLocales,\n                global,\n                locale,\n                overrideAccess,\n                parentIndexPath: '',\n                parentIsLocalized: parentIsLocalized || field.localized,\n                parentPath: path + '.' + rowIndex,\n                parentSchemaPath: schemaPath,\n                populate,\n                populationPromises,\n                req,\n                showHiddenFields,\n                siblingDoc: (row as JsonObject) || {},\n                triggerAccessControl,\n                triggerHooks,\n              })\n            })\n          }\n        })\n      } else if (shouldHoistLocalizedValue && (!rows || rows.length === 0)) {\n        siblingDoc[field.name] = null\n      } else if (field.hidden !== true || showHiddenFields === true) {\n        siblingDoc[field.name] = []\n      }\n      break\n    }\n\n    case 'blocks': {\n      const rows = siblingDoc[field.name]\n\n      if (Array.isArray(rows) && rows.length > 0) {\n        rows.forEach((row, rowIndex) => {\n          const blockTypeToMatch = (row as JsonObject).blockType\n\n          const block: Block | undefined =\n            req.payload.blocks[blockTypeToMatch] ??\n            ((field.blockReferences ?? field.blocks).find(\n              (curBlock) => typeof curBlock !== 'string' && curBlock.slug === blockTypeToMatch,\n            ) as Block | undefined)\n\n          const { blockSelect, blockSelectMode } = getBlockSelect({\n            block: block!,\n            // TODO: fix this\n            // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain\n            select: select?.[field.name]!,\n            selectMode: selectMode!,\n          })\n\n          if (block) {\n            traverseFields({\n              blockData: row,\n              collection,\n              context,\n              currentDepth,\n              depth,\n              doc,\n              draft,\n              fallbackLocale,\n              fieldPromises,\n              fields: block.fields,\n              findMany,\n              flattenLocales,\n              global,\n              locale,\n              overrideAccess,\n              parentIndexPath: '',\n              parentIsLocalized: parentIsLocalized || field.localized,\n              parentPath: path + '.' + rowIndex,\n              parentSchemaPath: schemaPath + '.' + block.slug,\n              populate,\n              populationPromises,\n              req,\n              select: typeof blockSelect === 'object' ? blockSelect : undefined,\n              selectMode: blockSelectMode,\n              showHiddenFields,\n              siblingDoc: (row as JsonObject) || {},\n              triggerAccessControl,\n              triggerHooks,\n            })\n          }\n        })\n      } else if (!shouldHoistLocalizedValue && typeof rows === 'object' && rows !== null) {\n        Object.values(rows).forEach((localeRows) => {\n          if (Array.isArray(localeRows)) {\n            localeRows.forEach((row, rowIndex) => {\n              const blockTypeToMatch = row.blockType\n\n              const block: Block | undefined =\n                req.payload.blocks[blockTypeToMatch] ??\n                ((field.blockReferences ?? field.blocks).find(\n                  (curBlock) => typeof curBlock !== 'string' && curBlock.slug === blockTypeToMatch,\n                ) as Block | undefined)\n\n              if (block) {\n                traverseFields({\n                  blockData: row,\n                  collection,\n                  context,\n                  currentDepth,\n                  depth,\n                  doc,\n                  draft,\n                  fallbackLocale,\n                  fieldPromises,\n                  fields: block.fields,\n                  findMany,\n                  flattenLocales,\n                  global,\n                  locale,\n                  overrideAccess,\n                  parentIndexPath: '',\n                  parentIsLocalized: parentIsLocalized || field.localized,\n                  parentPath: path + '.' + rowIndex,\n                  parentSchemaPath: schemaPath + '.' + block.slug,\n                  populate,\n                  populationPromises,\n                  req,\n                  showHiddenFields,\n                  siblingDoc: (row as JsonObject) || {},\n                  triggerAccessControl,\n                  triggerHooks,\n                })\n              }\n            })\n          }\n        })\n      } else if (shouldHoistLocalizedValue && (!rows || rows.length === 0)) {\n        siblingDoc[field.name] = null\n      } else if (field.hidden !== true || showHiddenFields === true) {\n        siblingDoc[field.name] = []\n      }\n\n      break\n    }\n\n    case 'collapsible':\n    case 'row': {\n      traverseFields({\n        blockData,\n        collection,\n        context,\n        currentDepth,\n        depth,\n        doc,\n        draft,\n        fallbackLocale,\n        fieldPromises,\n        fields: field.fields,\n        findMany,\n        flattenLocales,\n        global,\n        locale,\n        overrideAccess,\n        parentIndexPath: indexPath,\n        parentIsLocalized,\n        parentPath,\n        parentSchemaPath: schemaPath,\n        populate,\n        populationPromises,\n        req,\n        select,\n        selectMode,\n        showHiddenFields,\n        siblingDoc,\n        triggerAccessControl,\n        triggerHooks,\n      })\n\n      break\n    }\n\n    case 'group': {\n      if (fieldAffectsDataResult) {\n        let groupDoc = siblingDoc[field.name] as JsonObject\n\n        if (typeof siblingDoc[field.name] !== 'object') {\n          groupDoc = {}\n        }\n\n        const groupSelect = select?.[field.name]\n\n        traverseFields({\n          blockData,\n          collection,\n          context,\n          currentDepth,\n          depth,\n          doc,\n          draft,\n          fallbackLocale,\n          fieldPromises,\n          fields: field.fields,\n          findMany,\n          flattenLocales,\n          global,\n          locale,\n          overrideAccess,\n          parentIndexPath: '',\n          parentIsLocalized: parentIsLocalized || field.localized,\n          parentPath: path,\n          parentSchemaPath: schemaPath,\n          populate,\n          populationPromises,\n          req,\n          select: typeof groupSelect === 'object' ? groupSelect : undefined,\n          selectMode,\n          showHiddenFields,\n          siblingDoc: groupDoc,\n          triggerAccessControl,\n          triggerHooks,\n        })\n      } else {\n        traverseFields({\n          blockData,\n          collection,\n          context,\n          currentDepth,\n          depth,\n          doc,\n          draft,\n          fallbackLocale,\n          fieldPromises,\n          fields: field.fields,\n          findMany,\n          flattenLocales,\n          global,\n          locale,\n          overrideAccess,\n          parentIndexPath: indexPath,\n          parentIsLocalized,\n          parentPath,\n          parentSchemaPath: schemaPath,\n          populate,\n          populationPromises,\n          req,\n          select,\n          selectMode,\n          showHiddenFields,\n          siblingDoc,\n          triggerAccessControl,\n          triggerHooks,\n        })\n      }\n\n      break\n    }\n\n    case 'richText': {\n      if (!field?.editor) {\n        throw new MissingEditorProp(field) // while we allow disabling editor functionality, you should not have any richText fields defined if you do not have an editor\n      }\n\n      if (typeof field?.editor === 'function') {\n        throw new Error('Attempted to access unsanitized rich text editor.')\n      }\n\n      const editor: RichTextAdapter = field?.editor\n\n      if (editor?.hooks?.afterRead?.length) {\n        for (const hook of editor.hooks.afterRead) {\n          const shouldRunHookOnAllLocales =\n            fieldShouldBeLocalized({ field, parentIsLocalized: parentIsLocalized! }) &&\n            (locale === 'all' || !flattenLocales) &&\n            typeof siblingDoc[field.name] === 'object'\n\n          if (shouldRunHookOnAllLocales) {\n            const localesAndValues = Object.entries(siblingDoc[field.name])\n\n            await Promise.all(\n              localesAndValues.map(async ([locale, value]) => {\n                const hookedValue = await hook({\n                  collection,\n                  context,\n                  currentDepth,\n                  data: doc,\n                  depth,\n                  draft,\n                  fallbackLocale: fallbackLocale!,\n                  field,\n                  fieldPromises,\n                  findMany,\n                  flattenLocales,\n                  global,\n                  indexPath: indexPathSegments,\n                  locale,\n                  operation: 'read',\n                  originalDoc: doc,\n                  overrideAccess,\n                  parentIsLocalized: parentIsLocalized!,\n                  path: pathSegments,\n                  populate,\n                  populationPromises,\n                  req,\n                  schemaPath: schemaPathSegments,\n                  showHiddenFields,\n                  siblingData: siblingDoc,\n                  triggerAccessControl,\n                  triggerHooks,\n                  value,\n                })\n\n                if (hookedValue !== undefined) {\n                  siblingDoc[field.name][locale] = hookedValue\n                }\n              }),\n            )\n          } else {\n            const hookedValue = await hook({\n              collection,\n              context,\n              currentDepth,\n              data: doc,\n              depth,\n              draft,\n              fallbackLocale: fallbackLocale!,\n              field,\n              fieldPromises,\n              findMany,\n              flattenLocales,\n              global,\n              indexPath: indexPathSegments,\n              locale: locale!,\n              operation: 'read',\n              originalDoc: doc,\n              overrideAccess,\n              parentIsLocalized: parentIsLocalized!,\n              path: pathSegments,\n              populate,\n              populationPromises,\n              req,\n              schemaPath: schemaPathSegments,\n              showHiddenFields,\n              siblingData: siblingDoc,\n              triggerAccessControl,\n              triggerHooks,\n              value: siblingDoc[field.name],\n            })\n\n            if (hookedValue !== undefined) {\n              siblingDoc[field.name] = hookedValue\n            }\n          }\n        }\n      }\n      break\n    }\n\n    case 'tab': {\n      let tabDoc = siblingDoc\n      let tabSelect: SelectType | undefined\n\n      const isNamedTab = tabHasName(field)\n\n      if (isNamedTab) {\n        tabDoc = siblingDoc[field.name] as JsonObject\n\n        if (typeof siblingDoc[field.name] !== 'object') {\n          tabDoc = {}\n        }\n\n        if (typeof select?.[field.name] === 'object') {\n          tabSelect = select?.[field.name] as SelectType\n        }\n      } else {\n        tabSelect = select\n      }\n\n      traverseFields({\n        blockData,\n        collection,\n        context,\n        currentDepth,\n        depth,\n        doc,\n        draft,\n        fallbackLocale,\n        fieldPromises,\n        fields: field.fields,\n        findMany,\n        flattenLocales,\n        global,\n        locale,\n        overrideAccess,\n        parentIndexPath: isNamedTab ? '' : indexPath,\n        parentIsLocalized: parentIsLocalized || field.localized,\n        parentPath: isNamedTab ? path : parentPath,\n        parentSchemaPath: schemaPath,\n        populate,\n        populationPromises,\n        req,\n        select: tabSelect,\n        selectMode,\n        showHiddenFields,\n        siblingDoc: tabDoc,\n        triggerAccessControl,\n        triggerHooks,\n      })\n\n      break\n    }\n\n    case 'tabs': {\n      traverseFields({\n        blockData,\n        collection,\n        context,\n        currentDepth,\n        depth,\n        doc,\n        draft,\n        fallbackLocale,\n        fieldPromises,\n        fields: field.tabs.map((tab) => ({ ...tab, type: 'tab' })),\n        findMany,\n        flattenLocales,\n        global,\n        locale,\n        overrideAccess,\n        parentIndexPath: indexPath,\n        parentIsLocalized,\n        parentPath: path,\n        parentSchemaPath: schemaPath,\n        populate,\n        populationPromises,\n        req,\n        select,\n        selectMode,\n        showHiddenFields,\n        siblingDoc,\n        triggerAccessControl,\n        triggerHooks,\n      })\n\n      break\n    }\n    default: {\n      break\n    }\n  }\n}\n"],"names":["MissingEditorProp","getBlockSelect","stripUnselectedFields","fieldAffectsData","fieldShouldBeLocalized","tabHasName","getDefaultValue","getFieldPathsModified","getFieldPaths","relationshipPopulationPromise","traverseFields","virtualFieldPopulationPromise","promise","blockData","collection","context","currentDepth","depth","doc","draft","fallbackLocale","field","fieldIndex","fieldPromises","findMany","flattenLocales","global","locale","overrideAccess","parentIndexPath","parentIsLocalized","parentPath","parentSchemaPath","populate","populationPromises","req","select","selectMode","showHiddenFields","siblingDoc","siblingFields","triggerAccessControl","triggerHooks","indexPath","path","schemaPath","index","fieldAffectsDataResult","pathSegments","split","schemaPathSegments","indexPathSegments","filter","Boolean","map","Number","removedFieldValue","hidden","name","shouldContinue","shouldHoistLocalizedValue","payload","config","localization","value","hoistedValue","fallbackValue","isNullOrUndefined","type","pointDoc","Array","isArray","coordinates","length","undefined","editor","Error","tabs","forEach","tab","hooks","afterRead","hook","shouldRunHookOnAllLocales","localesAndValues","Object","entries","Promise","all","localeKey","hookedValue","data","operation","originalDoc","siblingData","virtual","push","fields","flattenedFields","ref","segments","allowDefaultValue","access","read","canReadField","id","defaultValue","user","rows","arraySelect","row","rowIndex","localized","values","localeRows","blockTypeToMatch","blockType","block","blocks","blockReferences","find","curBlock","slug","blockSelect","blockSelectMode","groupDoc","groupSelect","tabDoc","tabSelect","isNamedTab"],"mappings":"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"}