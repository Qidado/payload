{"version":3,"sources":["../../../src/queues/errors/handleTaskError.ts"],"sourcesContent":["import ObjectIdImport from 'bson-objectid'\n\nimport type { PayloadRequest } from '../../index.js'\nimport type { RunJobsSilent } from '../localAPI.js'\nimport type { UpdateJobFunction } from '../operations/runJobs/runJob/getUpdateJobFunction.js'\nimport type { TaskError } from './index.js'\n\nimport { getCurrentDate } from '../utilities/getCurrentDate.js'\nimport { calculateBackoffWaitUntil } from './calculateBackoffWaitUntil.js'\nimport { getWorkflowRetryBehavior } from './getWorkflowRetryBehavior.js'\n\nconst ObjectId = (ObjectIdImport.default ||\n  ObjectIdImport) as unknown as typeof ObjectIdImport.default\n\nexport async function handleTaskError({\n  error,\n  req,\n  silent = false,\n  updateJob,\n}: {\n  error: TaskError\n  req: PayloadRequest\n  /**\n   * If set to true, the job system will not log any output to the console (for both info and error logs).\n   * Can be an option for more granular control over logging.\n   *\n   * This will not automatically affect user-configured logs (e.g. if you call `console.log` or `payload.logger.info` in your job code).\n   *\n   * @default false\n   */\n  silent?: RunJobsSilent\n  updateJob: UpdateJobFunction\n}): Promise<{\n  hasFinalError: boolean\n}> {\n  const {\n    executedAt,\n    input,\n    job,\n    output,\n    parent,\n    retriesConfig,\n    taskConfig,\n    taskID,\n    taskSlug,\n    taskStatus,\n    workflowConfig,\n  } = error.args\n\n  if (taskConfig?.onFail) {\n    await taskConfig.onFail()\n  }\n\n  const errorJSON = {\n    name: error.name,\n    cancelled: Boolean('cancelled' in error && error.cancelled),\n    message: error.message,\n    stack: error.stack,\n  }\n\n  const currentDate = getCurrentDate()\n\n  ;(job.log ??= []).push({\n    id: new ObjectId().toHexString(),\n    completedAt: currentDate.toISOString(),\n    error: errorJSON,\n    executedAt: executedAt.toISOString(),\n    input,\n    output: output ?? {},\n    parent: req.payload.config.jobs.addParentToTaskLog ? parent : undefined,\n    state: 'failed',\n    taskID,\n    taskSlug,\n  })\n\n  if (job.waitUntil) {\n    // Check if waitUntil is in the past\n    const waitUntil = new Date(job.waitUntil)\n    if (waitUntil < currentDate) {\n      // Outdated waitUntil, remove it\n      delete job.waitUntil\n    }\n  }\n\n  let maxRetries: number = 0\n\n  if (retriesConfig?.attempts === undefined || retriesConfig?.attempts === null) {\n    // Inherit retries from workflow config, if they are undefined and the workflow config has retries configured\n    if (workflowConfig.retries !== undefined && workflowConfig.retries !== null) {\n      maxRetries =\n        typeof workflowConfig.retries === 'object'\n          ? typeof workflowConfig.retries.attempts === 'number'\n            ? workflowConfig.retries.attempts\n            : 0\n          : workflowConfig.retries\n    } else {\n      maxRetries = 0\n    }\n  } else {\n    maxRetries = retriesConfig.attempts\n  }\n\n  if (!taskStatus?.complete && (taskStatus?.totalTried ?? 0) >= maxRetries) {\n    /**\n     * Task reached max retries => workflow will not retry\n     */\n\n    await updateJob({\n      error: errorJSON,\n      hasError: true,\n      log: job.log,\n      processing: false,\n      totalTried: (job.totalTried ?? 0) + 1,\n      waitUntil: job.waitUntil,\n    })\n\n    if (!silent || (typeof silent === 'object' && !silent.error)) {\n      req.payload.logger.error({\n        err: error,\n        job,\n        msg: `Error running task ${taskID}. Attempt ${job.totalTried} - max retries reached`,\n        taskSlug,\n      })\n    }\n    return {\n      hasFinalError: true,\n    }\n  }\n\n  /**\n   * Task can retry:\n   * - If workflow can retry, allow it to retry\n   * - If workflow reached max retries, do not retry and set final error\n   */\n\n  // First set task waitUntil - if the workflow waitUntil is later, it will be updated later\n  const taskWaitUntil: Date = calculateBackoffWaitUntil({\n    retriesConfig,\n    totalTried: taskStatus?.totalTried ?? 0,\n  })\n\n  // Update job's waitUntil only if this waitUntil is later than the current one\n  if (!job.waitUntil || taskWaitUntil > new Date(job.waitUntil)) {\n    job.waitUntil = taskWaitUntil.toISOString()\n  }\n\n  const { hasFinalError, maxWorkflowRetries, waitUntil } = getWorkflowRetryBehavior({\n    job,\n    retriesConfig: workflowConfig.retries,\n  })\n\n  if (!silent || (typeof silent === 'object' && !silent.error)) {\n    req.payload.logger.error({\n      err: error,\n      job,\n      msg: `Error running task ${taskID}. Attempt ${job.totalTried + 1}${maxWorkflowRetries !== undefined ? '/' + (maxWorkflowRetries + 1) : ''}`,\n      taskSlug,\n    })\n  }\n\n  // Update job's waitUntil only if this waitUntil is later than the current one\n  if (waitUntil && (!job.waitUntil || waitUntil > new Date(job.waitUntil))) {\n    job.waitUntil = waitUntil.toISOString()\n  }\n\n  // Tasks update the job if they error - but in case there is an unhandled error (e.g. in the workflow itself, not in a task)\n  // we need to ensure the job is updated to reflect the error\n  await updateJob({\n    error: hasFinalError ? errorJSON : undefined,\n    hasError: hasFinalError, // If reached max retries => final error. If hasError is true this job will not be retried\n    log: job.log,\n    processing: false,\n    totalTried: (job.totalTried ?? 0) + 1,\n    waitUntil: job.waitUntil,\n  })\n\n  return {\n    hasFinalError,\n  }\n}\n"],"names":["ObjectIdImport","getCurrentDate","calculateBackoffWaitUntil","getWorkflowRetryBehavior","ObjectId","default","handleTaskError","error","req","silent","updateJob","executedAt","input","job","output","parent","retriesConfig","taskConfig","taskID","taskSlug","taskStatus","workflowConfig","args","onFail","errorJSON","name","cancelled","Boolean","message","stack","currentDate","log","push","id","toHexString","completedAt","toISOString","payload","config","jobs","addParentToTaskLog","undefined","state","waitUntil","Date","maxRetries","attempts","retries","complete","totalTried","hasError","processing","logger","err","msg","hasFinalError","taskWaitUntil","maxWorkflowRetries"],"mappings":"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"}